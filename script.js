document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Element References --- (Same as before)
    const parent1Input = document.getElementById('parent1');
    const parent2Input = document.getElementById('parent2');
    const patternSelect = document.getElementById('inheritance-pattern');
    const numGenesInput = document.getElementById('num-genes');
    const polygenicOptionsDiv = document.getElementById('polygenic-options');
    const calculateBtn = document.getElementById('calculate-btn');
    const resultsArea = document.getElementById('results-area');
    const errorMessageDiv = document.getElementById('error-message');
    const punnettSquareContainer = document.getElementById('punnett-square-container');
    const genotypeRatiosUl = document.getElementById('genotype-ratios');
    const phenotypeRatiosUl = document.getElementById('phenotype-ratios');
    const pedigreeContainer = document.getElementById('pedigree-chart-container');
    const phenotypeDefSection = document.getElementById('phenotype-definition');
    const phenotypeInputsDiv = document.getElementById('phenotype-inputs');
    const xLinkedHint = document.getElementById('x-linked-hint') || { style: {} };
    const codominanceHint = document.getElementById('codominance-hint') || { style: {} };
    const parent1NormalizedPreview = document.getElementById('parent1-normalized');
    const parent2NormalizedPreview = document.getElementById('parent2-normalized');
    const dashboardSection = document.getElementById('dashboard-section');
    const summaryGenoCount = document.getElementById('summary-genotype-count');
    const summaryPhenoCount = document.getElementById('summary-phenotype-count');
    const summaryPhenoRatio = document.getElementById('summary-phenotype-ratio');
    const genotypeChartDiv = document.getElementById('genotype-chart');
    const phenotypeChartDiv = document.getElementById('phenotype-chart');
    const genotypeYAxisDiv = document.getElementById('genotype-y-axis');
    const phenotypeYAxisDiv = document.getElementById('phenotype-y-axis');

    let userPhenotypes = {};
    let phenotypeColorMap = {};
    let nextColorIndex = 0;
    const phenotypeColorClasses = Array.from({ length: 16 }, (_, i) => `pheno-color-${i + 1}`);

    // --- Helper Functions --- (Same as before)
    function clearResults() { errorMessageDiv.textContent = ''; errorMessageDiv.style.display = 'none'; punnettSquareContainer.innerHTML = ''; genotypeRatiosUl.innerHTML = ''; phenotypeRatiosUl.innerHTML = ''; pedigreeContainer.innerHTML = ''; summaryGenoCount.textContent = '0'; summaryPhenoCount.textContent = '0'; summaryPhenoRatio.textContent = '-'; if(genotypeChartDiv) genotypeChartDiv.innerHTML = ''; if(phenotypeChartDiv) phenotypeChartDiv.innerHTML = ''; if(genotypeYAxisDiv) genotypeYAxisDiv.innerHTML = ''; if(phenotypeYAxisDiv) phenotypeYAxisDiv.innerHTML = ''; if (dashboardSection) dashboardSection.style.display = 'none'; phenotypeColorMap = {}; nextColorIndex = 0; userPhenotypes = {}; }
    function showError(message) { errorMessageDiv.textContent = message; errorMessageDiv.style.display = 'block'; resultsArea.style.display = 'block'; punnettSquareContainer.innerHTML = ''; genotypeRatiosUl.innerHTML = ''; phenotypeRatiosUl.innerHTML = ''; pedigreeContainer.innerHTML = ''; if (dashboardSection) dashboardSection.style.display = 'none'; }
    function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b); }
    function calculateSimplestRatio(counts) { const values = Object.values(counts).filter(v => v > 0).map(v => Math.round(v)); if (values.length === 0) return "-"; if (values.length === 1) return "1"; let resultGcd = values[0]; for (let i = 1; i < values.length; i++) { resultGcd = gcd(resultGcd, values[i]); } if (resultGcd === 0) return Object.keys(counts).filter(key => counts[key] > 0).map(() => '0').join(':'); const sortedKeys = Object.keys(counts).sort((keyA, keyB) => { if (patternSelect.value === 'polygenic' && keyA.includes('X') && keyB.includes('X') && keyA.includes('x') && keyB.includes('x')) { const numXA = parseInt(keyA.substring(0, keyA.indexOf('X')), 10); const numXB = parseInt(keyB.substring(0, keyB.indexOf('X')), 10); return numXA - numXB; } if (patternSelect.value.includes('linked') && (keyA.includes('(雌性)') || keyA.includes('(雄性)'))) { const sexOrder = {'(雌性)': 1, '(雄性)': 2}; const sexAKey = keyA.match(/\(([^)]+)\)$/)?.[1]; const sexBKey = keyB.match(/\(([^)]+)\)$/)?.[1]; const sexA = sexOrder[sexAKey] || 3; const sexB = sexOrder[sexBKey] || 3; if (sexA !== sexB) return sexA - sexB; const phenoA = keyA.replace(/\s*\([^)]+\)$/, ''); const phenoB = keyB.replace(/\s*\([^)]+\)$/, ''); return phenoA.localeCompare(phenoB); } return keyA.localeCompare(keyB); }); const ratioParts = sortedKeys.filter(key => counts[key] > 0).map(key => Math.round(counts[key]) / resultGcd); return ratioParts.join(':'); }

    // --- Normalization, Sorting, Validation Functions --- (Same as before)
    function sortAllelePair(allele1, allele2) { const a = allele1; const b = allele2; if (!a || !b) return (a || '') + (b || ''); if (a.toUpperCase() === a && b.toLowerCase() === b && a.toLowerCase() === b.toLowerCase()) return a + b; if (b.toUpperCase() === b && a.toLowerCase() === a && b.toLowerCase() === a.toLowerCase()) return b + a; return [a, b].sort().join(''); }
    function sortAndStandardizeMultiGene(genotype) { if (!genotype || genotype.length < 2 || genotype.length % 2 !== 0) { return genotype; } try { const geneLetters = Array.from(new Set(genotype.toLowerCase().split(''))).sort(); const groupedAlleles = {}; geneLetters.forEach(l => groupedAlleles[l] = []); for (let i = 0; i < genotype.length; i++) { const allele = genotype[i]; const lower = allele.toLowerCase(); if (groupedAlleles.hasOwnProperty(lower)) { groupedAlleles[lower].push(allele); } else { console.warn(`Unexpected allele '${allele}' skipped in multi-gene sort of '${genotype}' (gene '${lower}' not identified?). Skipping.`); } } const sortedPairs = []; for (const letter of geneLetters) { const alleles = groupedAlleles[letter]; if (alleles.length === 2) { sortedPairs.push(sortAllelePair(alleles[0], alleles[1])); } else if (alleles.length === 0) {} else { console.warn(`Gene ${letter} has unexpected allele count: ${alleles.length} in ${genotype}. Joining as is: ${alleles.sort().join('')}`); sortedPairs.push(alleles.sort().join('')); } } return sortedPairs.join(''); } catch (e) { console.error(`Error in sortAndStandardizeMultiGene for '${genotype}':`, e); return genotype; } }
    function normalizeABO(input) { const trimmedInput = input.trim().toUpperCase(); if (trimmedInput === 'A' || trimmedInput === 'AO' || trimmedInput === 'OA' || trimmedInput === 'AI' || trimmedInput === 'IA') return 'IAi'; if (trimmedInput === 'AA' || trimmedInput === 'IAIA') return 'IAIA'; if (trimmedInput === 'B' || trimmedInput === 'BO' || trimmedInput === 'OB' || trimmedInput === 'BI' || trimmedInput === 'IB') return 'IBi'; if (trimmedInput === 'BB' || trimmedInput === 'IBIB') return 'IBIB'; if (trimmedInput === 'AB' || trimmedInput === 'BA' || trimmedInput === 'IAIB' || trimmedInput === 'IBIA') return 'IAIB'; if (trimmedInput === 'O' || trimmedInput === 'OO' || trimmedInput === 'II') return 'ii'; const standardFormats = ['IAIA', 'IAi', 'IBIB', 'IBi', 'IAIB', 'ii']; if (standardFormats.includes(input.trim())) return input.trim(); return input.trim(); }
    function normalizeGenotypeInput(genotype, pattern) { let normalized = genotype.trim().replace(/ /g, ''); if (!normalized) return ''; switch(pattern) { case 'codominance': normalized = normalizeABO(normalized); const stdABO = ['IAIA', 'IAi', 'IBIB', 'IBi', 'IAIB', 'ii']; if (!stdABO.includes(normalized) && normalized.length === 2 && !normalized.includes('I')) { normalized = sortAllelePair(normalized[0], normalized[1]); } break; case 'two-genes-independent': case 'polygenic': if (normalized.length >= 4 && normalized.length % 2 === 0) { normalized = sortAndStandardizeMultiGene(normalized); } break; case 'complete': case 'incomplete': if (normalized.length === 2) { normalized = sortAllelePair(normalized[0], normalized[1]); } break; case 'x-linked': if (normalized.length === 4 && normalized.toLowerCase().startsWith('xx')) { let a1 = normalized[1]; let a2 = normalized[3]; if (normalized[2].toLowerCase() !== 'x') { a1 = normalized[2]; a2 = normalized[3]; } const sortedPair = sortAllelePair(a1, a2); normalized = 'X' + sortedPair[0] + 'X' + sortedPair[1]; } else if (normalized.length === 3 && normalized.toLowerCase().endsWith('y')) { normalized = 'X' + normalized[1] + 'Y'; } break; case 'y-linked': if (normalized.length === 3 && normalized.toLowerCase().startsWith('xy')) { normalized = 'X' + 'Y' + normalized[2].toUpperCase(); } else if (normalized.toLowerCase() === 'xy') { normalized = 'XY'; } else if (normalized.toLowerCase() === 'xx') { normalized = 'XX'; } break; } return normalized; }
    function displayNormalized(inputElement, previewElement, pattern) { const rawValue = inputElement.value; const normalizedValue = normalizeGenotypeInput(rawValue, pattern); if (rawValue && normalizedValue && rawValue.trim().replace(/ /g,'') !== normalizedValue) { previewElement.textContent = `(標準化: ${normalizedValue})`; } else { previewElement.textContent = ''; } }
    function validateGenotype(genotype, pattern, numGenes = 0) { if (!genotype) { showError("基因型不能為空。"); return false;} const normForCheck = normalizeGenotypeInput(genotype, pattern); if (!normForCheck && genotype) { showError(`基因型 "${genotype}" 無法標準化或格式無效。`); return false; } if (!normForCheck && !genotype) { showError("基因型不能為空。"); return false; } const allowedChars = pattern === 'codominance' ? /^[A-Za-zXYi]+$/i : /^[A-Za-zXY]+$/i; if (!allowedChars.test(normForCheck)) { showError(`基因型 "${genotype}" 包含無效字元 (標準化後 "${normForCheck}"，模式 ${pattern}).`); return false; } switch (pattern) { case 'complete': case 'incomplete': if (normForCheck.length !== 2) { showError(`單基因 (${pattern}) 格式錯誤 (應為2個字母). 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } break; case 'codominance': const aboR=/^IAIA$|^IAi$|^IBIB$|^IBi$|^IAIB$|^ii$/; const simpleCoDom=/^[A-Za-z]{2}$/; if (!aboR.test(normForCheck) && !(simpleCoDom.test(normForCheck) && !normForCheck.includes('I'))) { showError(`共顯性/ABO 格式錯誤. 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } break; case 'x-linked': const xLR = /^X[A-Za-z]X[A-Za-z]$|^X[A-Za-z]?Y$/i; if (!xLR.test(normForCheck)) { showError(`X-連鎖格式錯誤 (例: XAXa, XaY). 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } break; case 'y-linked': if (!/^XX$|^XY[A-Z]?$/i.test(normForCheck)) { showError(`Y-連鎖格式錯誤 (例: XX, XY, XYA). 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } break; case 'two-genes-independent': if (normForCheck.length !== 4) { showError(`雙基因格式錯誤 (應為4個字母). 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } const ul2 = new Set(normForCheck.toLowerCase().split('')); if (ul2.size > 2) { showError(`雙基因 "${genotype}" 含超過2種基因字母 (${Array.from(ul2).join(',')}).`); return false; } break; case 'polygenic': if (numGenes <= 0) { showError("請指定有效的多基因對數 (1-4)。"); return false; } if (normForCheck.length !== 2 * numGenes) { showError(`多基因 (${numGenes}對) 長度應為 ${2 * numGenes}. 輸入: "${genotype}", 標準化: "${normForCheck}"`); return false; } const ulP = new Set(normForCheck.toLowerCase().split('')); if (ulP.size !== numGenes) { showError(`多基因 "${genotype}" 基因種類 (${ulP.size}) 與指定對數 (${numGenes}) 不符.`); return false; } break; default: break; } return true; }
    function validateGenotypeSilent(genotype, pattern, numGenes = 0) { if (!genotype) return false; const normForCheck = normalizeGenotypeInput(genotype, pattern); if (!normForCheck) return false; const allowedChars = pattern === 'codominance' ? /^[A-Za-zXYi]+$/i : /^[A-Za-zXY]+$/i; if (!allowedChars.test(normForCheck)) return false; switch (pattern) { case 'complete': case 'incomplete': return normForCheck.length === 2; case 'codominance': const aboR=/^IAIA$|^IAi$|^IBIB$|^IBi$|^IAIB$|^ii$/; const simpleCoDom=/^[A-Za-z]{2}$/; return aboR.test(normForCheck) || (simpleCoDom.test(normForCheck) && !normForCheck.includes('I')); case 'x-linked': const xLR = /^X[A-Za-z]X[A-Za-z]$|^X[A-Za-z]?Y$/i; return xLR.test(normForCheck); case 'y-linked': return /^XX$|^XY[A-Z]?$/i.test(normForCheck); case 'two-genes-independent': if(normForCheck.length !== 4) return false; return new Set(normForCheck.toLowerCase().split('')).size <= 2; case 'polygenic': if (numGenes <= 0 || normForCheck.length !== 2 * numGenes) return false; return new Set(normForCheck.toLowerCase().split('')).size === numGenes; } return true; }

    // --- Core Logic Functions --- (Same as before)
    function getFemaleXAlleles(genotype) { if (genotype.length === 4 && genotype.startsWith('X') && genotype[2] === 'X') { return [genotype[1], genotype[3]]; } return null; }
    function sortGenotypeString(genotype, pattern) { if (!genotype) return genotype; switch (pattern) { case 'two-genes-independent': case 'polygenic': return sortAndStandardizeMultiGene(genotype); case 'x-linked': if (genotype.includes('Y')) return genotype; if (genotype.length === 4 && genotype.startsWith('X') && genotype[2] === 'X') { const sortedPair = sortAllelePair(genotype[1], genotype[3]); return 'X' + sortedPair[0] + 'X' + sortedPair[1]; } return genotype; case 'codominance': if (genotype === 'iIA') return 'IAi'; if (genotype === 'iIB') return 'IBi'; if (genotype === 'IBIA') return 'IAIB'; const stdABO = ['IAIA', 'IAi', 'IBIB', 'IBi', 'IAIB', 'ii']; if (!stdABO.includes(genotype) && genotype.length === 2) { return sortAllelePair(genotype[0], genotype[1]); } return genotype; case 'complete': case 'incomplete': default: if (genotype.length === 2) { return sortAllelePair(genotype[0], genotype[1]); } return genotype; } }
    function generateGametes(genotype, pattern, numGenes = 0) { const normGeno = genotype; try { switch (pattern) { case 'complete': case 'incomplete': return Array.from(new Set([normGeno[0], normGeno[1]])); case 'codominance': if (normGeno === 'IAIA') return ['IA']; if (normGeno === 'IAi') return ['IA', 'i']; if (normGeno === 'IBIB') return ['IB']; if (normGeno === 'IBi') return ['IB', 'i']; if (normGeno === 'IAIB') return ['IA', 'IB']; if (normGeno === 'ii') return ['i']; if (normGeno.length === 2 && !normGeno.includes('I')) return Array.from(new Set([normGeno[0], normGeno[1]])); throw new Error(`無法識別共顯性基因型: ${normGeno}`); case 'x-linked': if (normGeno.includes('Y')) { const alleleOnX = normGeno.length === 3 ? normGeno[1] : ''; return ['X' + alleleOnX, 'Y']; } else { const alleles = getFemaleXAlleles(normGeno); if (alleles) { return Array.from(new Set(['X' + alleles[0], 'X' + alleles[1]])); } else { throw new Error(`無法解析雌性X連鎖基因型: ${normGeno}`); } } case 'y-linked': if (normGeno.startsWith('XY')) { const alleleOnY = normGeno.length === 3 ? normGeno[2] : ''; return ['X', 'Y' + alleleOnY]; } else if (normGeno === 'XX') { return ['X']; } else { throw new Error(`無效的Y連鎖基因型: ${normGeno}`); } case 'two-genes-independent': if (normGeno.length !== 4) throw new Error(`雙基因型長度錯誤(內部): ${normGeno}`); const g1A = [normGeno[0], normGeno[1]]; const g2A = [normGeno[2], normGeno[3]]; const gams = new Set(); for (const a1 of g1A) { for (const a2 of g2A) { gams.add(a1 + a2); } } return Array.from(gams); case 'polygenic': if (normGeno.length !== 2 * numGenes) throw new Error(`多基因長度與基因對數(${numGenes})不符(內部): ${normGeno}`); const generateCombinations = (index, currentGamete) => { if (index === numGenes) return [currentGamete]; const allele1 = normGeno[index * 2]; const allele2 = normGeno[index * 2 + 1]; let results = generateCombinations(index + 1, currentGamete + allele1); if (allele1.toLowerCase() !== allele2.toLowerCase() || allele1 !== allele2) { results = results.concat(generateCombinations(index + 1, currentGamete + allele2)); } return results; }; return Array.from(new Set(generateCombinations(0, ''))); default: throw new Error(`未知的遺傳模式: ${pattern}`); } } catch (error) { showError(`生成配子錯誤 (${normGeno}, ${pattern}): ${error.message}`); return null; } }
    function createPunnettData(gametes1, gametes2, pattern) { const punnettData = []; for (const g2 of gametes2) { const row = []; for (const g1 of gametes1) { let offspringGenotypeRaw; if ((pattern === 'x-linked' || pattern === 'y-linked') && (g1.includes('X') || g1.includes('Y') || g2.includes('X') || g2.includes('Y'))) { const isMaleCross = (g1.includes('X') && g2.includes('Y')) || (g1.includes('Y') && g2.includes('X')); const isFemaleCross = g1.includes('X') && g2.includes('X'); if (isFemaleCross && pattern === 'x-linked') { offspringGenotypeRaw = 'X' + g1.substring(1) + 'X' + g2.substring(1); } else if (isFemaleCross && pattern === 'y-linked') { offspringGenotypeRaw = 'XX'; } else if (isMaleCross) { const xGamete = g1.includes('X') ? g1 : g2; const yGamete = g1.includes('Y') ? g1 : g2; offspringGenotypeRaw = xGamete + yGamete; } else { offspringGenotypeRaw = g1 + g2; console.warn(`Unexpected gamete combo in ${pattern}: ${g1}+${g2}`); } } else { offspringGenotypeRaw = g1 + g2; } const offspringGenotypeSorted = sortGenotypeString(offspringGenotypeRaw, pattern); row.push(offspringGenotypeSorted); } punnettData.push(row); } return punnettData; }

    // --- Phenotype Determination --- (Same as before, including NXmx format for Polygenic)
    function getPhenotypeColorClass(phenotype) { if (!phenotypeColorMap[phenotype]) { phenotypeColorMap[phenotype] = phenotypeColorClasses[nextColorIndex % phenotypeColorClasses.length]; nextColorIndex++; } return phenotypeColorMap[phenotype]; }
    function isABOImplied(pattern) { if (pattern !== 'codominance') return false; const p1Norm = normalizeGenotypeInput(parent1Input.value, 'codominance'); const p2Norm = normalizeGenotypeInput(parent2Input.value, 'codominance'); const aboChars = /[ABOiI]/; return aboChars.test(p1Norm) || aboChars.test(p2Norm); }
    function getPhenotypeAndSex(genotype, pattern, userPhenos, numGenes = 0) { let phenotype = "未知"; let sex = '未知/常染色體'; if (!genotype) return { phenotype, sex }; if (pattern.includes('linked')) { if (genotype.includes('Y')) { sex = '雄性'; } else if (genotype.includes('X')) { sex = '雌性'; } } const lookupGenotype = genotype; try { switch (pattern) { case 'complete': if (lookupGenotype.length === 2) { const a1 = lookupGenotype[0]; const a2 = lookupGenotype[1]; const isRecessive = a1 === a1.toLowerCase() && a2 === a2.toLowerCase(); const dominantAllele = a1.toUpperCase(); const recessiveAllele = a1.toLowerCase(); const dominantHomozygoteKey = sortAllelePair(dominantAllele, dominantAllele); const heterozygoteKey = sortAllelePair(dominantAllele, recessiveAllele); const recessiveHomozygoteKey = sortAllelePair(recessiveAllele, recessiveAllele); if (userPhenos[lookupGenotype]) { phenotype = userPhenos[lookupGenotype]; } else { const phenoDominant = userPhenos[dominantHomozygoteKey] || `顯性 (${dominantAllele})`; const phenoRecessive = userPhenos[recessiveHomozygoteKey] || `隱性 (${recessiveAllele})`; phenotype = isRecessive ? phenoRecessive : phenoDominant; } } else { phenotype = lookupGenotype; } break; case 'incomplete': case 'codominance': if (isABOImplied(pattern)) { if (userPhenos[lookupGenotype]) { phenotype = userPhenos[lookupGenotype]; } else { if (lookupGenotype === 'IAIA' || lookupGenotype === 'IAi') phenotype = userPhenos['A']; else if (lookupGenotype === 'IBIB' || lookupGenotype === 'IBi') phenotype = userPhenos['B']; else if (lookupGenotype === 'IAIB') phenotype = userPhenos['AB']; else if (lookupGenotype === 'ii') phenotype = userPhenos['O']; } if (!phenotype) { if (lookupGenotype === 'IAIA' || lookupGenotype === 'IAi') phenotype = "A 型"; else if (lookupGenotype === 'IBIB' || lookupGenotype === 'IBi') phenotype = "B 型"; else if (lookupGenotype === 'IAIB') phenotype = "AB 型"; else if (lookupGenotype === 'ii') phenotype = "O 型"; else phenotype = lookupGenotype; } } else { phenotype = userPhenos[lookupGenotype] || lookupGenotype; } break; case 'x-linked': if (userPhenos[lookupGenotype]) { phenotype = userPhenos[lookupGenotype]; } else { const alleles = getFemaleXAlleles(lookupGenotype); const alleleOnX = sex === '雄性' && lookupGenotype.length === 3 ? lookupGenotype[1] : null; let isDominantPhenotype = false; if (sex === '雌性' && alleles) { isDominantPhenotype = alleles[0] === alleles[0].toUpperCase() || alleles[1] === alleles[1].toUpperCase(); } else if (sex === '雄性' && alleleOnX) { isDominantPhenotype = alleleOnX === alleleOnX.toUpperCase(); } const phenoDomCat = userPhenos['DOM'] || '顯性'; const phenoRecCat = userPhenos['REC'] || '隱性'; phenotype = isDominantPhenotype ? phenoDomCat : phenoRecCat; } break; case 'y-linked': phenotype = userPhenos[lookupGenotype]; if (!phenotype) { if (sex === '雄性') { const alleleOnY = lookupGenotype.length === 3 ? lookupGenotype[2] : null; phenotype = alleleOnY ? `Y-連鎖 (${alleleOnY})` : `無Y等位基因`; } else { phenotype = "無Y染色體"; } } break; case 'two-genes-independent': if (lookupGenotype.length === 4) { if (userPhenos[lookupGenotype]) { phenotype = userPhenos[lookupGenotype]; } else { const g1a1 = lookupGenotype[0]; const g1a2 = lookupGenotype[1]; const g1IsRec = g1a1 === g1a1.toLowerCase() && g1a2 === g1a2.toLowerCase(); const g1DomKey = g1a1.toUpperCase(); const g1RecKey = g1a1.toLowerCase(); const p1 = g1IsRec ? (userPhenos[g1RecKey] || g1RecKey) : (userPhenos[g1DomKey] || g1DomKey); const g2a1 = lookupGenotype[2]; const g2a2 = lookupGenotype[3]; const g2IsRec = g2a1 === g2a1.toLowerCase() && g2a2 === g2a2.toLowerCase(); const g2DomKey = g2a1.toUpperCase(); const g2RecKey = g2a1.toLowerCase(); const p2 = g2IsRec ? (userPhenos[g2RecKey] || g2RecKey) : (userPhenos[g2DomKey] || g2DomKey); phenotype = `${p1}-${p2}`; } } else { phenotype = lookupGenotype; } break; case 'polygenic': if (lookupGenotype.length === 2 * numGenes && numGenes > 0) { if (userPhenos[lookupGenotype]) { phenotype = userPhenos[lookupGenotype]; } else { let dominantAlleleCount = 0; for (let i = 0; i < lookupGenotype.length; i++) { if (lookupGenotype[i] === lookupGenotype[i].toUpperCase() && lookupGenotype[i] !== lookupGenotype[i].toLowerCase()) { dominantAlleleCount++; } } const totalAlleles = 2 * numGenes; const recessiveAlleleCount = totalAlleles - dominantAlleleCount; phenotype = `${dominantAlleleCount}X${recessiveAlleleCount}x`; } } else { phenotype = "基因型長度錯誤"; } break; default: phenotype = lookupGenotype; break; } } catch (e) { console.error("獲取表現型錯誤:", lookupGenotype, pattern, e); phenotype = "計算錯誤"; } if (pattern.includes('linked')) { phenotype = `${phenotype} (${sex})`; } return { phenotype, sex }; }

    // --- UI Generation and Rendering Functions ---
    function createPhenotypeInputGroup(labelText, dataKey, placeholder, dataType = 'genotype') { const group = document.createElement('div'); group.className = 'phenotype-input-group'; const label = document.createElement('label'); label.textContent = labelText; label.htmlFor = `pheno-${dataKey}`; const input = document.createElement('input'); input.type = 'text'; input.id = `pheno-${dataKey}`; input.dataset.type = dataType; input.dataset.key = dataKey; input.placeholder = placeholder; group.appendChild(label); group.appendChild(input); return group; }
    function generatePhenotypeInputs(pattern) { phenotypeInputsDiv.innerHTML = ''; let showSection = false; try { if (pattern === 'complete') { showSection = true; let dA='A', rA='a'; const af = new Set(); [parent1Input.value, parent2Input.value].forEach(rg => { const ng = normalizeGenotypeInput(rg, pattern); if (validateGenotypeSilent(ng, pattern)) { af.add(ng[0].toUpperCase()); } }); const sa = Array.from(af).sort(); if (sa.length >= 1) { dA = sa[0]; rA = dA.toLowerCase(); } const dH = sortAllelePair(dA, dA); const rH = sortAllelePair(rA, rA); const he = sortAllelePair(dA, rA); phenotypeInputsDiv.innerHTML = '<span>為表現型命名 (選填):</span>'; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`顯性 (${dH}/${he}):`, dH, `例: ${dA} 特徵`, 'phenotype_category')); phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`隱性 (${rH}):`, rH, `例: ${rA} 特徵`, 'phenotype_category')); } else if (pattern === 'incomplete' || (pattern === 'codominance' && !isABOImplied(pattern))) { showSection = true; let pgs = new Set(); let als = new Set(); [parent1Input.value,parent2Input.value].forEach(rg=>{const ng=normalizeGenotypeInput(rg,pattern);if(validateGenotypeSilent(ng,pattern) && !ng.includes('I')){als.add(ng[0]); als.add(ng[1]);}}); const al=Array.from(als).sort(); if(al.length===1){pgs.add(sortAllelePair(al[0],al[0]));}else if(al.length>=2){pgs.add(sortAllelePair(al[0],al[0])); pgs.add(sortAllelePair(al[0],al[1])); pgs.add(sortAllelePair(al[1],al[1]));}else{pgs.add("AA");pgs.add("Aa");pgs.add("aa");} const title = pattern === 'incomplete' ? '為基因型命名 (不全顯性):' : '為基因型命名 (共顯 - 非ABO):'; phenotypeInputsDiv.innerHTML = `<span>${title}</span>`; Array.from(pgs).sort().forEach(gt => { phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`${gt}:`, gt, `例: ${gt} 表現型`, 'genotype')); }); } else if (pattern === 'codominance' && isABOImplied(pattern)) { showSection = true; phenotypeInputsDiv.innerHTML = '<span>為 ABO 血型命名 (選填):</span>'; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`A 型 (IAIA/IAi):`, 'A', `A 型`, 'phenotype_category')); phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`B 型 (IBIB/IBi):`, 'B', `B 型`, 'phenotype_category')); phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`AB 型 (IAIB):`, 'AB', `AB 型`, 'phenotype_category')); phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`O 型 (ii):`, 'O', `O 型`, 'phenotype_category')); } else if (pattern === 'two-genes-independent') { showSection = true; let ap = {}; let gf = new Set(); [parent1Input.value, parent2Input.value].forEach(rg => { const ng = normalizeGenotypeInput(rg, pattern); if (validateGenotypeSilent(ng, pattern)) { for(let i=0; i < ng.length; i++) { const al = ng[i]; const g = al.toLowerCase(); gf.add(g); if (!ap[al]) { const iD = al === al.toUpperCase() && al !== al.toLowerCase(); ap[al] = {label: `${iD ? '顯' : '隱'} (${al}):`, ph: `例: ${al} 特徵`}; } } } }); phenotypeInputsDiv.innerHTML = '<span>為各等位基因命名特徵 (選填):</span>'; const sa = Object.keys(ap).sort((a, b) => { const la = a.toLowerCase(); const lb = b.toLowerCase(); if (la !== lb) return la.localeCompare(lb); return b.localeCompare(a); }); if (sa.length > 0) { sa.forEach(al => { const d = ap[al]; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(d.label, al, d.ph, 'allele')); }); } else { phenotypeInputsDiv.innerHTML = '<span>輸入有效雙基因親代以定義。</span>'; } } else if (pattern === 'x-linked') { showSection = true; phenotypeInputsDiv.innerHTML = '<span>為 X-連鎖表現型命名 (選填):</span>'; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`顯性表現:`, 'DOM', `例: 顯性特徵`, 'phenotype_category')); phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`隱性表現:`, 'REC', `例: 隱性特徵`, 'phenotype_category')); } else if (pattern === 'y-linked') { showSection = true; phenotypeInputsDiv.innerHTML = '<span>為 Y-連鎖表現型命名 (選填):</span>'; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`XX 個體:`, 'XX', `例: 無Y特徵`, 'genotype')); let yAllele = null; const p1N=normalizeGenotypeInput(parent1Input.value,pattern); const p2N=normalizeGenotypeInput(parent2Input.value,pattern); if(validateGenotypeSilent(p1N,pattern) && p1N.startsWith('XY') && p1N.length === 3) yAllele = p1N[2]; if(validateGenotypeSilent(p2N,pattern) && p2N.startsWith('XY') && p2N.length === 3) yAllele = yAllele || p2N[2]; if(yAllele) { const maleGenoKey = 'XY' + yAllele; phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`雄性 (${maleGenoKey}):`, maleGenoKey, `例: Y連鎖(${yAllele})特徵`, 'genotype')); } else { phenotypeInputsDiv.appendChild(createPhenotypeInputGroup(`雄性 (XY):`, 'XY', `例: 無Y等位基因特徵`, 'genotype')); } } } catch (e) { console.error("生成表現型輸入錯誤:", e); phenotypeInputsDiv.innerHTML = '<span>生成輸入時出錯。</span>'; showSection = false; } phenotypeDefSection.style.display = showSection ? 'block' : 'none'; }
    function calculateRatios(punnettData, pattern, userPhenotypes, parent1Genotype, parent2Genotype) { const genotypeCounts = {}; const phenotypeCounts = {}; const offspringDetails = []; let totalOffspring = 0; let numGenes = 0; if (pattern === 'polygenic') { if (validateGenotypeSilent(parent1Genotype, pattern, parent1Genotype.length / 2)) { numGenes = parent1Genotype.length / 2; } else if (validateGenotypeSilent(parent2Genotype, pattern, parent2Genotype.length / 2)) { numGenes = parent2Genotype.length / 2; } else { console.warn("Could not determine numGenes for polygenic calculation."); } } for (const row of punnettData) { for (const genotype of row) { if (!genotype) continue; totalOffspring++; genotypeCounts[genotype] = (genotypeCounts[genotype] || 0) + 1; const { phenotype, sex } = getPhenotypeAndSex(genotype, pattern, userPhenotypes, numGenes); phenotypeCounts[phenotype] = (phenotypeCounts[phenotype] || 0) + 1; offspringDetails.push({ genotype, phenotype, sex }); } } return { genotypeCounts, phenotypeCounts, totalOffspring, offspringDetails }; }
    function renderPunnettSquare(gametes1, gametes2, punnettData, pattern, userPhenotypes, numGenes = 0) { punnettSquareContainer.innerHTML = ''; const table = document.createElement('table'); table.className = 'punnett-table'; const hr = table.insertRow(); const ec = hr.insertCell(); ec.className = 'empty-cell'; gametes1.forEach(g => { const th = document.createElement('th'); th.textContent = g; hr.appendChild(th); }); gametes2.forEach((g2, rIdx) => { const row = table.insertRow(); const th = document.createElement('th'); th.textContent = g2; row.appendChild(th); punnettData[rIdx].forEach(og => { const cell = row.insertCell(); cell.textContent = og; cell.className = 'genotype-cell'; if (og) { const { phenotype: cp } = getPhenotypeAndSex(og, pattern, userPhenotypes, numGenes); const basePheno = cp.replace(/\s*\([^)]+\)$/, ''); const cc = getPhenotypeColorClass(basePheno); cell.classList.add(cc); cell.title = `表現型: ${cp}`; } }); }); punnettSquareContainer.appendChild(table); }
    function renderRatios(ulElement, counts, total, typeLabel) { ulElement.innerHTML = ''; if (total === 0) { ulElement.innerHTML = `<li>無${typeLabel}結果</li>`; return; } const lh = document.createElement('li'); lh.style.cssText = 'font-weight: bold; border-left: none; background: none; margin-bottom: 10px; padding-left: 0;'; if (typeLabel === '表現型' && patternSelect.value === 'polygenic') { lh.textContent = '表現型 分佈: (X表示所有顯性遺傳因子，x表示所有隱性遺傳因子)'; } else { lh.textContent = `${typeLabel} 分佈:`; } ulElement.appendChild(lh); const sortedKeys = Object.keys(counts).sort((keyA, keyB) => { if (typeLabel === '表現型' && patternSelect.value === 'polygenic' && keyA.includes('X') && keyB.includes('X') && keyA.includes('x') && keyB.includes('x')) { const numXA = parseInt(keyA.substring(0, keyA.indexOf('X')), 10); const numXB = parseInt(keyB.substring(0, keyB.indexOf('X')), 10); return numXA - numXB; } if (typeLabel === '表現型' && patternSelect.value.includes('linked')) { const sexOrder = {'(雌性)': 1, '(雄性)': 2}; const sexAKey = keyA.match(/\(([^)]+)\)$/)?.[1]; const sexBKey = keyB.match(/\(([^)]+)\)$/)?.[1]; const sexA = sexOrder[sexAKey] || 3; const sexB = sexOrder[sexBKey] || 3; if (sexA !== sexB) return sexA - sexB; const phenoA = keyA.replace(/\s*\([^)]+\)$/, ''); const phenoB = keyB.replace(/\s*\([^)]+\)$/, ''); return phenoA.localeCompare(phenoB); } return keyA.localeCompare(keyB); }); sortedKeys.forEach(item => { const count = counts[item]; const perc = (count / total) * 100; const li = document.createElement('li'); let rc = 'ratio-low'; if (perc >= 70) rc = 'ratio-high'; else if (perc >= 40) rc = 'ratio-medium'; else if (perc < 15) rc = 'ratio-very-low'; li.classList.add(rc); li.textContent = `${item}: `; const cs = document.createElement('span'); cs.textContent = `${count}/${total}`; cs.style.marginLeft = '5px'; const ps = document.createElement('span'); ps.className = 'ratio-value'; ps.textContent = `(${perc.toFixed(1)}%)`; ps.style.marginLeft = '5px'; li.appendChild(cs); li.appendChild(ps); ulElement.appendChild(li); }); }
    function renderPedigree(genotype1, genotype2, offspringDetails, pattern, userPhenotypes) { pedigreeContainer.innerHTML = ''; let ng = 0; if (pattern === 'polygenic') { if (validateGenotypeSilent(genotype1, pattern, genotype1.length / 2)) { ng = genotype1.length / 2; } else if (validateGenotypeSilent(genotype2, pattern, genotype2.length / 2)) { ng = genotype2.length / 2; } } const pL = document.createElement('div'); pL.className = 'pedigree-level parents'; const { sex: s1, phenotype: p1 } = getPhenotypeAndSex(genotype1, pattern, userPhenotypes, ng); const { sex: s2, phenotype: p2 } = getPhenotypeAndSex(genotype2, pattern, userPhenotypes, ng); function cIE(id, sex, geno, pheno) { const iD = document.createElement('div'); iD.className = 'pedigree-individual'; const sy = document.createElement('div'); sy.className = `pedigree-symbol ${sex === '雄性' ? 'male' : sex === '雌性' ? 'female' : 'unknown'}`; sy.innerHTML = id; const baseP = pheno.replace(/\s*\([^)]+\)$/, ''); const cC = getPhenotypeColorClass(baseP); sy.classList.add(cC); const gD = document.createElement('div'); gD.className = 'pedigree-genotype'; gD.textContent = geno; const pD = document.createElement('div'); pD.className = 'pedigree-phenotype'; pD.textContent = pheno; iD.appendChild(sy); iD.appendChild(gD); iD.appendChild(pD); return iD; } pL.appendChild(cIE('P1', s1, genotype1, p1)); pL.appendChild(cIE('P2', s2, genotype2, p2)); pedigreeContainer.appendChild(pL); const cnD = document.createElement('div'); cnD.className = 'pedigree-connectors'; pedigreeContainer.appendChild(cnD); const oL = document.createElement('div'); oL.className = 'pedigree-level offspring'; if (offspringDetails && offspringDetails.length > 0) { const maxD = 10; const uOM = new Map(); offspringDetails.forEach(o => { const { phenotype: op, sex: os } = getPhenotypeAndSex(o.genotype, pattern, userPhenotypes, pattern === 'polygenic' ? o.genotype.length / 2 : 0); const k = `${o.genotype}-${os}`; if (!uOM.has(k)) { uOM.set(k, { genotype: o.genotype, phenotype: op, sex: os }); } }); const uOL = Array.from(uOM.values()).sort((a, b) => a.genotype.localeCompare(b.genotype) || a.sex.localeCompare(b.sex)); const dO = uOL.slice(0, maxD); dO.forEach((o, idx) => { oL.appendChild(cIE(`F1<sub>${idx + 1}</sub>`, o.sex, o.genotype, o.phenotype)); }); if (uOL.length > maxD) { const mI = document.createElement('div'); mI.textContent = `(...等 ${uOL.length - maxD} 種其他組合)`; mI.style.cssText = 'font-size:12px;color:#555;width:100%;text-align:center;margin-top:10px;flex-basis:100%;padding-left:20px;'; oL.appendChild(mI); } } else { oL.textContent = '無子代結果'; } pedigreeContainer.appendChild(oL); }

    // --- renderBarChart (MODIFIED to use Absolute Height) ---
    /**
     * Renders bar chart with ABSOLUTE height against a fixed 0-100% Y-axis.
     * @param {HTMLElement} chartAreaContainer - Div for bars (#genotype-chart)
     * @param {HTMLElement} yAxisContainer - Div for Y-axis labels (#genotype-y-axis)
     * @param {Object} data - Counts object {key: count}
     * @param {number} total - Total offspring
     * @param {string} titlePrefix - '基因型' or '表現型'
     * @param {string} barClass - Specific CSS class ('bar' for default, 'pheno-bar' for phenotype)
     */
    function renderBarChart(chartAreaContainer, yAxisContainer, data, total, titlePrefix = '', barClass = 'bar') {
        chartAreaContainer.innerHTML = ''; // Clear previous bars
        yAxisContainer.innerHTML = ''; // Clear previous Y-axis labels

        if (!data || total === 0 || Object.keys(data).length === 0) {
            chartAreaContainer.textContent = `無${titlePrefix}數據可顯示。`;
            chartAreaContainer.style.justifyContent = 'center';
            yAxisContainer.innerHTML = '<span>100%</span><span>50%</span><span>0%</span>'; // Placeholder axis
            return;
        }
        chartAreaContainer.style.justifyContent = 'center'; // Default alignment

        const entries = Object.entries(data);

        // Sorting Logic (same as before)
        entries.sort(([keyA], [keyB]) => {
            if (titlePrefix === '表現型' && patternSelect.value === 'polygenic' && keyA.includes('X') && keyB.includes('X') && keyA.includes('x') && keyB.includes('x')) { const numXA = parseInt(keyA.substring(0, keyA.indexOf('X')), 10); const numXB = parseInt(keyB.substring(0, keyB.indexOf('X')), 10); return numXA - numXB; }
             if (titlePrefix === '表現型' && patternSelect.value.includes('linked')) { const sexOrder = {'(雌性)': 1, '(雄性)': 2}; const sexAKey = keyA.match(/\(([^)]+)\)$/)?.[1]; const sexBKey = keyB.match(/\(([^)]+)\)$/)?.[1]; const sexA = sexOrder[sexAKey] || 3; const sexB = sexOrder[sexBKey] || 3; if (sexA !== sexB) return sexA - sexB; const phenoA = keyA.replace(/\s*\([^)]+\)$/, ''); const phenoB = keyB.replace(/\s*\([^)]+\)$/, ''); return phenoA.localeCompare(phenoB); }
            return keyA.localeCompare(keyB);
        });

        // Render FIXED Y-Axis Labels (0%, 50%, 100%)
        const yLabel100 = document.createElement('span'); yLabel100.textContent = '100%';
        const yLabel50 = document.createElement('span'); yLabel50.textContent = '50%';
        const yLabel0 = document.createElement('span'); yLabel0.textContent = '0%';
        yAxisContainer.appendChild(yLabel100);
        yAxisContainer.appendChild(yLabel50);
        yAxisContainer.appendChild(yLabel0);

        // Render Bars using ABSOLUTE height
        entries.forEach(([key, count]) => {
            const percentage = total > 0 ? (count / total) * 100 : 0;
            // *** Use the direct percentage for height ***
            const barHeightPercent = percentage;

            const wrapper = document.createElement('div');
            wrapper.className = 'bar-wrapper';

            const bar = document.createElement('div');
            bar.className = 'bar ' + barClass; // Apply base and specific class
            // Set height based on the absolute percentage
            bar.style.height = `${barHeightPercent}%`;
            bar.title = `${key}: ${count}/${total} (${percentage.toFixed(1)}%)`; // Tooltip

            const label = document.createElement('div');
            label.className = 'bar-label';
            label.textContent = key;
            label.title = key;

            wrapper.appendChild(bar);
            wrapper.appendChild(label);
            chartAreaContainer.appendChild(wrapper);
        });

        // Adjust alignment for many bars
        if (entries.length > 8) {
             chartAreaContainer.style.justifyContent = 'flex-start';
         } else {
             chartAreaContainer.style.justifyContent = 'center';
         }
    }


    // --- Event Handlers --- (Same as before)
    function handlePatternChange() { const pattern = patternSelect.value; polygenicOptionsDiv.style.display = (pattern === 'polygenic') ? 'block' : 'none'; xLinkedHint.style.display = (pattern === 'x-linked') ? 'block' : 'none'; codominanceHint.style.display = (pattern === 'codominance') ? 'block' : 'none'; generatePhenotypeInputs(pattern); displayNormalized(parent1Input, parent1NormalizedPreview, pattern); displayNormalized(parent2Input, parent2NormalizedPreview, pattern); }
    function handleCalculation() { clearResults(); resultsArea.style.display = 'block'; const genotype1Raw = parent1Input.value; const genotype2Raw = parent2Input.value; const pattern = patternSelect.value; let numGenes = 0; if (pattern === 'polygenic') { numGenes = parseInt(numGenesInput.value, 10); if (isNaN(numGenes) || numGenes < 1 || numGenes > 4) { showError("請為多基因遺傳輸入有效的基因對數 (1-4)。"); return; } } userPhenotypes = {}; if (phenotypeDefSection.style.display === 'block') { const inputs = phenotypeInputsDiv.querySelectorAll('input[data-key]'); inputs.forEach(input => { const key = input.dataset.key; const phenotypeName = input.value.trim(); if (key && phenotypeName) { userPhenotypes[key] = phenotypeName; } }); } try { const genotype1 = normalizeGenotypeInput(genotype1Raw, pattern); const genotype2 = normalizeGenotypeInput(genotype2Raw, pattern); if (!validateGenotype(genotype1, pattern, numGenes) || !validateGenotype(genotype2, pattern, numGenes)) { return; } const gametes1 = generateGametes(genotype1, pattern, numGenes); const gametes2 = generateGametes(genotype2, pattern, numGenes); if (!gametes1 || !gametes2) return; const punnettData = createPunnettData(gametes1, gametes2, pattern); const { genotypeCounts, phenotypeCounts, totalOffspring, offspringDetails } = calculateRatios(punnettData, pattern, userPhenotypes, genotype1, genotype2); renderPunnettSquare(gametes1, gametes2, punnettData, pattern, userPhenotypes, numGenes); renderRatios(genotypeRatiosUl, genotypeCounts, totalOffspring, "基因型"); renderRatios(phenotypeRatiosUl, phenotypeCounts, totalOffspring, "表現型"); renderPedigree(genotype1, genotype2, offspringDetails, pattern, userPhenotypes); try { const genotypeCount = Object.keys(genotypeCounts).length; const phenotypeCount = Object.keys(phenotypeCounts).length; summaryGenoCount.textContent = genotypeCount; summaryPhenoCount.textContent = phenotypeCount; summaryPhenoRatio.textContent = calculateSimplestRatio(phenotypeCounts); // Render charts using the updated renderBarChart function
        renderBarChart(genotypeChartDiv, genotypeYAxisDiv, genotypeCounts, totalOffspring, '基因型', 'bar'); renderBarChart(phenotypeChartDiv, phenotypeYAxisDiv, phenotypeCounts, totalOffspring, '表現型', 'pheno-bar'); if(dashboardSection) dashboardSection.style.display = 'block'; } catch (dashboardError) { console.error("渲染儀表板時出錯:", dashboardError); if(dashboardSection) dashboardSection.style.display = 'none'; } } catch (error) { showError(`計算過程錯誤: ${error.message}`); console.error("Calculation Error Details:", error); if(dashboardSection) dashboardSection.style.display = 'none'; } }

    // --- Event Listener Assignments & Initialization --- (Same as before)
    patternSelect.addEventListener('change', handlePatternChange);
    calculateBtn.addEventListener('click', handleCalculation);
    parent1Input.addEventListener('input', () => { generatePhenotypeInputs(patternSelect.value); displayNormalized(parent1Input, parent1NormalizedPreview, patternSelect.value); });
    parent2Input.addEventListener('input', () => { generatePhenotypeInputs(patternSelect.value); displayNormalized(parent2Input, parent2NormalizedPreview, patternSelect.value); });
    handlePatternChange(); // Initial setup

}); // End DOMContentLoaded wrapper